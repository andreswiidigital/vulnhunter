import { BaseExploit } from './base';
import { RegistrationExploit } from './registration';
import { IDORExploit } from './idor';
import { SQLInjectionExploit } from './sqli';

export class ExploitFactory {
  static create(type: string, targetUrl: string, vulnerability: any): BaseExploit | null {
    switch (type) {
      case 'registration':
        return new RegistrationExploit(targetUrl, vulnerability);
      case 'idor':
        return new IDORExploit(targetUrl, vulnerability);
      case 'sqli':
        return new SQLInjectionExploit(targetUrl, vulnerability);
      // Estes tipos já são provados pelo scanner — não precisam de exploit separado
      case 'misconfiguration':
      case 'information_disclosure':
      case 'auth_bypass':
      case 'rate_limit':
        return null;
      default:
        return null;
    }
  }
}
