export interface ExploitResult {
  success: boolean;
  exploits: any[];
  evidence: any[];
  logs: LogEntry[];
  startedAt: string;
  completedAt: string | null;
  duration: number;
  summary?: {
    totalAttempts?: number;
    successful?: number;
    failed?: number;
    accountsCreated?: number;
    resourcesAccessed?: number;
    sensitiveData?: number;
  };
}

export interface LogEntry {
  timestamp: string;
  level: 'info' | 'success' | 'error' | 'warning';
  message: string;
}

export interface VulnerabilityData {
  id: string;
  type: string;
  endpoint: string;
  method?: string;
  parameter?: string;
  severity: string;
  description?: string;
}

export abstract class BaseExploit {
  protected targetUrl: string;
  protected vulnerability: VulnerabilityData;
  protected results: ExploitResult;

  constructor(targetUrl: string, vulnerability: VulnerabilityData) {
    this.targetUrl = targetUrl.replace(/\/$/, ''); // Remove trailing slash
    this.vulnerability = vulnerability;
    this.results = {
      success: false,
      exploits: [],
      evidence: [],
      logs: [],
      startedAt: new Date().toISOString(),
      completedAt: null,
      duration: 0,
    };
  }

  protected log(message: string, level: LogEntry['level'] = 'info') {
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
    };
    this.results.logs.push(logEntry);
    console.log(`[${level.toUpperCase()}] ${message}`);
  }

  protected addEvidence(type: string, content: any) {
    this.results.evidence.push({
      type,
      content,
      timestamp: new Date().toISOString(),
    });
  }

  protected generateCurlCommand(method: string, url: string, options: any = {}): string {
    const { headers = {}, body } = options;
    let curl = `curl -X ${method} '${url}'`;
    
    Object.entries(headers).forEach(([key, value]) => {
      curl += ` -H '${key}: ${value}'`;
    });
    
    if (body) {
      curl += ` -d '${JSON.stringify(body)}'`;
    }
    
    return curl;
  }

  protected finalize(): ExploitResult {
    this.results.completedAt = new Date().toISOString();
    const start = new Date(this.results.startedAt).getTime();
    const end = new Date(this.results.completedAt).getTime();
    this.results.duration = (end - start) / 1000;
    return this.results;
  }

  abstract execute(): Promise<ExploitResult>;
  abstract getPayloads(): any[];
}
